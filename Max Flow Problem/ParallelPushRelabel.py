# -*- coding: utf-8 -*-
"""ParallelPushRelabel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cD25kzFAr3lfT43K8-oNzb2Y6JlecdL-
"""

import concurrent.futures  # Module for parallel execution
import numpy as np         # Module for array and matrix operations
import time                # Module to track execution time

class ParallelPushRelabel:
    def __init__(self, graph):
        # Initialize graph parameters
        self.n = len(graph)                     # Number of nodes
        self.capacity = np.array(graph)         # Capacity matrix from the provided graph
        self.flow = np.zeros((self.n, self.n), dtype=int)  # Flow matrix initialized to zero
        self.excess = np.zeros(self.n, dtype=int)          # Excess flow array for each node
        self.height = np.zeros(self.n, dtype=int)          # Height of each node for priority in push-relabel

    def initialize_preflow(self, source):
        # Initialize preflow at the source node
        self.height[source] = self.n  # Set height of source to the number of nodes
        for v in range(self.n):
            if self.capacity[source][v] > 0:    # If there's capacity from source to node v
                # Set initial flow from source to node v
                self.flow[source][v] = self.capacity[source][v]
                self.flow[v][source] = -self.capacity[source][v]  # Reverse flow for backtracking
                self.excess[v] = self.capacity[source][v]         # Excess flow at node v
                self.excess[source] -= self.capacity[source][v]   # Reduce excess at source by the pushed flow

    def push(self, u, v):
        # Push operation to send flow from node u to node v
        delta = min(self.excess[u], self.capacity[u][v] - self.flow[u][v])  # Max flow we can push
        self.flow[u][v] += delta           # Increase flow from u to v
        self.flow[v][u] -= delta           # Reverse flow for backtracking
        self.excess[u] -= delta            # Reduce excess at node u
        self.excess[v] += delta            # Increase excess at node v

    def relabel(self, u):
        # Relabel operation to increase the height of node u
        min_height = float('inf')
        for v in range(self.n):
            if self.capacity[u][v] - self.flow[u][v] > 0:   # If there's remaining capacity
                min_height = min(min_height, self.height[v])  # Find minimum height of reachable neighbors
        self.height[u] = min_height + 1  # Increase height of u

    def discharge(self, u):
        # Discharge operation to push or relabel until excess flow is zero
        while self.excess[u] > 0:  # While there's excess at u
            for v in range(self.n):
                if self.capacity[u][v] - self.flow[u][v] > 0 and self.height[u] == self.height[v] + 1:
                    self.push(u, v)  # Push flow if u's height is exactly 1 more than v's height
                    if self.excess[u] == 0:
                        break  # Stop if excess at u becomes zero
            else:
                self.relabel(u)  # Relabel if no push was possible

    def max_flow(self, source, sink):
        # Calculate max flow from source to sink
        self.initialize_preflow(source)
        active_nodes = [u for u in range(self.n) if u != source and u != sink]  # Nodes with potential excess

        with concurrent.futures.ThreadPoolExecutor() as executor:
            # Process active nodes in parallel
            while any(self.excess[u] > 0 for u in active_nodes):
                futures = [executor.submit(self.discharge, u) for u in active_nodes if self.excess[u] > 0]
                concurrent.futures.wait(futures)  # Wait for all nodes to finish discharging

        # Calculate total flow from source by summing all outgoing flows
        return sum(self.flow[source][v] for v in range(self.n))


# Test using the provided graph
graph = [
  [0, 16, 13, 0, 0, 0],  # Node 0
  [0, 0, 10, 12, 0, 0],  # Node 1
  [0, 4, 0, 0, 14, 0],   # Node 2
  [0, 0, 9, 0, 0, 20],   # Node 3
  [0, 0, 0, 7, 0, 4],    # Node 4
  [0, 0, 0, 0, 0, 0]     # Node 5
]

source = 0
sink = 5

# Measure the time to compute the max flow
start_time = time.time()

pp_relabel = ParallelPushRelabel(graph)
max_flow_value = pp_relabel.max_flow(source, sink)

end_time = time.time()
execution_time = end_time - start_time

# Output the max flow value and the time taken
print(f"Max flow from source {source} to sink {sink}: {max_flow_value}")
print(f"Execution Time: {execution_time:.6f} seconds")